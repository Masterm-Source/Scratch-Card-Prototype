/**
 * PROFESSIONAL DUAL CANVAS SCRATCH CARD GENERATOR
 * USES EXACT SAME LOGIC AS JOE'S SCRIPT - PIXEL PERFECT SCRATCHING
 * - Two separate canvases: message canvas (bottom) + scratch canvas (top)
 * - Real image loading for scratch textures (no CSS bullshit)
 * - Professional pixel-by-pixel scratching only
 * - Fireworks effects during scratching
 * - Pure canvas-to-canvas revealing
 */

class AdvancedCardGenerator {
    constructor() {
        this.baseUrl = process.env.BASE_URL || '';
    }

    /**
     * Generate a complete HTML scratch card with DUAL CANVAS SYSTEM
     */
    async generateCard(cardData) {
        const {
            id: cardId,
            senderName,
            hiddenMessage,
            backgroundImage,
            symbol,
            animation,
            scratchTexture,
            soundEffect,
            // Advanced features
            backgroundImageBase64,
            symbolBase64,
            scratchTextureBase64,
            soundEffectBase64,
            elements = [],
            cardStyle = {},
            glowEffect = 30,
            glowColor = '#667eea',
            smokeEffect = false,
            template = 'classic'
        } = cardData;

        // Generate the complete HTML document with DUAL CANVAS SYSTEM
        const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéØ Scratch Card from ${senderName} - Masterm Cards</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        ${this.generateWebAppCSS(cardData)}
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <div class="logo-section">
                <div class="logo-icon">üéØ</div>
                <div class="logo-text">Masterm Cards</div>
            </div>
            <div class="header-info">
                <span>Interactive Scratch Card</span>
            </div>
        </div>
        
        <div class="main-content">
            <div class="card-container">
                <div class="card-preview floating ${this.getCardClasses(cardData)}" id="cardPreview" ${this.generateCardInlineStyles(cardData)}>
                    ${this.generateDynamicCardElements(cardData)}
                </div>
            </div>
        </div>
        
        <!-- Audio elements -->
        <audio id="scratchSound" preload="auto">
            ${this.generateAudioSources(cardData)}
        </audio>
        
        <!-- Particle system container -->
        <div id="particleContainer"></div>
        
        <!-- Smoke effect container -->
        <div id="smokeContainer"></div>
    </div>

    <script>
        ${this.generateDualCanvasJavaScript(cardData)}
    </script>
</body>
</html>`;

        return html;
    }

    /**
     * Get CSS classes for the card element - handles both gradients and images
     */
    getCardClasses(cardData) {
        const { backgroundImage, cardStyle = {} } = cardData;
        
        // Priority: cardStyle.className > backgroundImage gradients > default
        if (cardStyle.className) {
            // Extract just the background class from full className
            const classes = cardStyle.className.split(' ');
            const bgClass = classes.find(cls => cls.startsWith('bg-obsidian-'));
            return bgClass || '';
        }
        
        // Check if backgroundImage is a gradient class
        if (backgroundImage && backgroundImage.startsWith('bg-obsidian-')) {
            return backgroundImage;
        }
        
        return '';
    }

    /**
     * Generate inline styles for the card element
     */
    generateCardInlineStyles(cardData) {
        const { cardStyle = {}, backgroundImage, backgroundImageBase64 } = cardData;
        let styles = [];

        // Priority order: cardStyle.backgroundImage > backgroundImageBase64 > regular backgroundImage
        
        if (cardStyle.backgroundImage && cardStyle.backgroundImage !== '') {
            styles.push(`background-image: ${cardStyle.backgroundImage}`);
            if (!cardStyle.backgroundSize) styles.push('background-size: cover');
            if (!cardStyle.backgroundPosition) styles.push('background-position: center');
        } else if (backgroundImageBase64) {
            styles.push(`background-image: url('${backgroundImageBase64}')`);
            styles.push('background-size: cover');
            styles.push('background-position: center');
        } else if (backgroundImage && !backgroundImage.startsWith('bg-obsidian-')) {
            if (this.isWebAppAsset(backgroundImage)) {
                styles.push(`background-image: url('${this.baseUrl}/assets/backgrounds/${backgroundImage}')`);
            } else {
                styles.push(`background-image: url('${backgroundImage}')`);
            }
            styles.push('background-size: cover');
            styles.push('background-position: center');
        }

        // Apply other cardStyle properties
        if (cardStyle.backgroundSize && !styles.some(s => s.includes('background-size'))) {
            styles.push(`background-size: ${cardStyle.backgroundSize}`);
        }
        if (cardStyle.backgroundPosition && !styles.some(s => s.includes('background-position'))) {
            styles.push(`background-position: ${cardStyle.backgroundPosition}`);
        }
        if (cardStyle.backgroundRepeat) styles.push(`background-repeat: ${cardStyle.backgroundRepeat}`);
        if (cardStyle.aspectRatio) styles.push(`aspect-ratio: ${cardStyle.aspectRatio}`);
        if (cardStyle.border) styles.push(`border: ${cardStyle.border}`);
        if (cardStyle.borderRadius) styles.push(`border-radius: ${cardStyle.borderRadius}`);

        return styles.length > 0 ? `style="${styles.join('; ')}"` : '';
    }

    /**
     * Check if an asset is from the web app's asset collection
     */
    isWebAppAsset(assetPath) {
        const fileNamePattern = /^[0-9a-zA-Z]+\.(jpeg|jpg|png|gif|mp3)$/;
        
        if (fileNamePattern.test(assetPath)) {
            return true;
        }
        
        if (assetPath.includes('/assets/backgrounds/') || 
            assetPath.includes('/assets/symbols/') || 
            assetPath.includes('/assets/scratchTextures/') ||
            assetPath.includes('/assets/audio/')) {
            return true;
        }
        
        return false;
    }

    /**
     * Generate card elements with DUAL CANVAS SYSTEM for scratch areas
     */
    generateDynamicCardElements(cardData) {
        const { 
            elements = [],
            template = 'classic',
            hiddenMessage = 'Surprise!'
        } = cardData;

        // If no elements provided, create basic template elements
        if (elements.length === 0) {
            return this.generateFallbackElements(cardData);
        }

        // Generate elements from the elements array
        let elementsHtml = '';
        
        elements.forEach((element, index) => {
            const elementHtml = this.generateSingleElement(element, index, cardData);
            if (elementHtml) {
                elementsHtml += elementHtml + '\n';
            }
        });

        return elementsHtml;
    }

    /**
     * Generate a single element with DUAL CANVAS for scratch areas
     */
    generateSingleElement(element, index, cardData) {
        const {
            id = `element-${index}`,
            type = 'text',
            content = '',
            innerHTML = '',
            position = {},
            style = {}
        } = element;

        // Build inline styles from position and style objects
        let inlineStyles = [];

        // Position styles
        if (position.left) inlineStyles.push(`left: ${position.left}`);
        if (position.top) inlineStyles.push(`top: ${position.top}`);
        if (position.width) inlineStyles.push(`width: ${position.width}`);
        if (position.height) inlineStyles.push(`height: ${position.height}`);

        // Element styles
        Object.keys(style).forEach(prop => {
            if (style[prop] && style[prop] !== 'initial' && style[prop] !== '') {
                const cssProp = prop.replace(/([A-Z])/g, '-$1').toLowerCase();
                inlineStyles.push(`${cssProp}: ${style[prop]}`);
            }
        });

        // Ensure position absolute for all elements
        if (!inlineStyles.some(s => s.startsWith('position:'))) {
            inlineStyles.push('position: absolute');
        }

        const styleAttr = inlineStyles.length > 0 ? `style="${inlineStyles.join('; ')}"` : '';

        // Generate element based on type
        switch (type) {
            case 'sender':
            case 'sender-name':
                return `<div class="card-element sender-name" id="${id}" ${styleAttr}>
                    ${innerHTML || content || 'From Anonymous'}
                </div>`;

            case 'scratch':
            case 'scratch-area':
                const hiddenMsg = cardData.hiddenMessage || 'Surprise!';
                const canvasWidth = this.parsePixels(position.width) || 350;
                const canvasHeight = this.parsePixels(position.height) || 150;
                
                return `<div class="card-element scratch-container" id="${id}" ${styleAttr}>
                    <canvas id="messageCanvas" width="${canvasWidth}" height="${canvasHeight}"></canvas>
                    <canvas id="scratchCanvas" width="${canvasWidth}" height="${canvasHeight}"></canvas>
                </div>`;

            case 'symbol':
            case 'card-symbol':
                let symbolContent = innerHTML || content;
                
                if (symbolContent.includes('<img')) {
                    // Already has image tag, keep as is
                } else if (symbolContent && (symbolContent.includes('data:image') || this.isWebAppAsset(symbolContent))) {
                    const imageSrc = this.isWebAppAsset(symbolContent) && !symbolContent.startsWith('data:') 
                        ? `${this.baseUrl}/assets/symbols/${symbolContent}`
                        : symbolContent;
                    symbolContent = `<img src="${imageSrc}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;" alt="Symbol">`;
                } else {
                    symbolContent = symbolContent || '‚ù§Ô∏è';
                }
                
                return `<div class="card-element card-symbol" id="${id}" ${styleAttr}>
                    ${symbolContent}
                </div>`;

            case 'text':
            case 'custom-text':
            default:
                return `<div class="card-element custom-element" id="${id}" ${styleAttr}>
                    ${innerHTML || content || 'Custom Element'}
                </div>`;
        }
    }

    /**
     * Parse pixel values from CSS strings
     */
    parsePixels(value) {
        if (typeof value === 'number') return value;
        if (typeof value === 'string') {
            const num = parseFloat(value);
            return isNaN(num) ? null : num;
        }
        return null;
    }

    /**
     * Fallback elements with DUAL CANVAS system
     */
    generateFallbackElements(cardData) {
        const { 
            senderName, 
            hiddenMessage, 
            symbol, 
            symbolBase64,
            template = 'classic' 
        } = cardData;

        if (template === 'blank') {
            return '<!-- Blank template - no fallback elements -->';
        }

        // Classic template fallback with DUAL CANVAS
        let symbolContent = '';
        if (symbolBase64) {
            symbolContent = `<img src="${symbolBase64}" alt="Symbol" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;">`;
        } else if (symbol && (symbol.includes('data:image') || this.isWebAppAsset(symbol))) {
            const symbolUrl = this.isWebAppAsset(symbol) && !symbol.startsWith('data:')
                ? `${this.baseUrl}/assets/symbols/${symbol}`
                : symbol;
            symbolContent = `<img src="${symbolUrl}" alt="Symbol" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;">`;
        } else {
            symbolContent = symbol || '‚ù§Ô∏è';
        }

        return `
            <div class="card-element sender-name" id="senderName" 
                 style="position: absolute; top: 20px; left: 20px;">
                From ${senderName || 'Anonymous'}
            </div>
            
            <div class="card-element scratch-container" id="scratchContainer" 
                 style="position: absolute; top: 45%; left: 16%; width: 350px; height: 150px;">
                <canvas id="messageCanvas" width="350" height="150"></canvas>
                <canvas id="scratchCanvas" width="350" height="150"></canvas>
            </div>
            
            <div class="card-element card-symbol" id="cardSymbol" 
                 style="position: absolute; top: 20px; right: 20px; width: 80px; height: 80px;">
                ${symbolContent}
            </div>
        `;
    }

    /**
     * Generate CSS with DUAL CANVAS styling
     */
    generateWebAppCSS(cardData) {
        const { 
            backgroundImage, 
            backgroundImageBase64, 
            glowColor = '#667eea', 
            glowEffect = 30,
            cardStyle = {}
        } = cardData;
        
        return `
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }

        .app-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            z-index: 1000;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.5);
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .logo-text {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-info {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: 500;
        }

        .main-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 80px 20px 20px;
            position: relative;
        }

        .card-container {
            position: relative;
            max-width: 800px;
            width: 100%;
        }

        /* CARD PREVIEW BASE STYLES */
        .card-preview {
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1.6;
            margin: 0 auto;
            border-radius: 16px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.5s ease;
            transform-style: preserve-3d;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            
            box-shadow: 
                0 0 ${glowEffect}px ${this.hexToRgba(glowColor, 0.9)},
                0 0 ${glowEffect * 2}px ${this.hexToRgba(glowColor, 0.6)},
                0 0 ${glowEffect * 3}px ${this.hexToRgba(glowColor, 0.3)},
                inset 0 0 ${glowEffect / 2}px rgba(255, 255, 255, 0.3),
                0 10px 30px rgba(0, 0, 0, 0.5);
            filter: drop-shadow(0 0 ${glowEffect}px ${this.hexToRgba(glowColor, 0.8)});
            position: relative;
            z-index: 10;
        }

        .card-preview:hover {
            transform: rotateY(5deg) rotateX(5deg);
            box-shadow: 
                0 0 ${glowEffect * 1.5}px ${this.hexToRgba(glowColor, 1)},
                0 0 ${glowEffect * 3}px ${this.hexToRgba(glowColor, 0.8)},
                0 0 ${glowEffect * 4}px ${this.hexToRgba(glowColor, 0.4)},
                0 20px 50px rgba(0, 0, 0, 0.7);
        }

        /* GRADIENT BACKGROUND CLASSES */
        .bg-obsidian-rose {
            background: linear-gradient(45deg, rgba(255, 154, 158, 0.3) 0%, rgba(254, 207, 239, 0.3) 50%, rgba(0, 0, 0, 0.8) 100%) !important;
        }

        .bg-obsidian-ocean {
            background: linear-gradient(45deg, rgba(168, 237, 234, 0.3) 0%, rgba(254, 214, 227, 0.3) 50%, rgba(0, 0, 0, 0.8) 100%) !important;
        }

        .bg-obsidian-galaxy {
            background: linear-gradient(45deg, rgba(210, 153, 194, 0.3) 0%, rgba(254, 249, 215, 0.3) 50%, rgba(0, 0, 0, 0.8) 100%) !important;
        }

        .bg-obsidian-gold {
            background: linear-gradient(45deg, rgba(246, 211, 101, 0.3) 0%, rgba(253, 160, 133, 0.3) 50%, rgba(0, 0, 0, 0.8) 100%) !important;
        }

        .bg-obsidian-sunset {
            background: linear-gradient(45deg, rgba(255, 138, 128, 0.3) 0%, rgba(255, 128, 171, 0.3) 50%, rgba(0, 0, 0, 0.8) 100%) !important;
        }

        .bg-obsidian-emerald {
            background: linear-gradient(45deg, rgba(132, 250, 176, 0.3) 0%, rgba(143, 211, 244, 0.3) 50%, rgba(0, 0, 0, 0.8) 100%) !important;
        }

        /* CARD ELEMENTS */
        .card-element {
            position: absolute;
            user-select: none;
            transition: all 0.3s ease;
        }

        .sender-name {
            color: white;
            font-weight: 600;
            font-size: 18px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* DUAL CANVAS SYSTEM - EXACT SAME AS JOE'S SCRIPT */
        .scratch-container {
            position: relative;
            cursor: crosshair;
            border-radius: 12px;
            overflow: hidden;
        }

        #messageCanvas, #scratchCanvas {
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 12px;
        }

        #messageCanvas {
            z-index: 1; /* Bottom layer - shows hidden message */
        }

        #scratchCanvas {
            z-index: 2; /* Top layer - scratch surface */
        }

        .card-symbol {
            font-size: 48px;
            opacity: 0.9;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            backdrop-filter: blur(5px);
        }

        .card-symbol:hover {
            opacity: 1;
            transform: scale(1.1) rotate(5deg);
        }

        .card-symbol img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }

        .custom-element {
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            backdrop-filter: blur(5px);
        }

        /* FLOATING ANIMATION */
        @keyframes floating {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        .floating {
            animation: floating 3s ease-in-out infinite;
        }

        /* RESPONSIVE DESIGN */
        @media (max-width: 768px) {
            .main-content {
                padding: 80px 10px 20px;
            }
            
            .card-preview {
                max-width: 100%;
            }
            
            .sender-name {
                font-size: 16px;
                padding: 10px 14px;
            }
            
            .card-symbol {
                font-size: 36px;
            }
        }
        `;
    }

    /**
     * Generate audio sources
     */
    generateAudioSources(cardData) {
        const { soundEffect, soundEffectBase64 } = cardData;
        
        if (soundEffectBase64) {
            return `<source src="${soundEffectBase64}" type="audio/mpeg">`;
        } else if (soundEffect && soundEffect !== '#beep') {
            const audioUrl = this.isWebAppAsset(soundEffect)
                ? `${this.baseUrl}/assets/audio/${soundEffect}`
                : soundEffect;
            return `<source src="${audioUrl}" type="audio/mpeg">`;
        }
        
        return '<!-- No custom audio - will use Web Audio API beep -->';
    }

    /**
     * Generate JavaScript with EXACT DUAL CANVAS SYSTEM from joe's script
     */
    generateDualCanvasJavaScript(cardData) {
        const { 
            hiddenMessage = 'Surprise!', 
            animation = 'hearts',
            glowColor = '#667eea',
            smokeEffect = false,
            scratchTexture,
            scratchTextureBase64
        } = cardData;

        // Get scratch texture URL
        let scratchTextureUrl = '';
        if (scratchTextureBase64) {
            scratchTextureUrl = scratchTextureBase64;
        } else if (scratchTexture && !scratchTexture.includes('data:image/svg+xml')) {
            if (this.isWebAppAsset(scratchTexture)) {
                scratchTextureUrl = `${this.baseUrl}/assets/scratchTextures/${scratchTexture}`;
            } else {
                scratchTextureUrl = scratchTexture;
            }
        }

        return `
        // DUAL CANVAS SYSTEM - EXACT SAME LOGIC AS JOE'S SCRIPT
        const messageCanvas = document.getElementById('messageCanvas');
        const scratchCanvas = document.getElementById('scratchCanvas');
        
        if (!messageCanvas || !scratchCanvas) {
            console.error('Dual canvas system not found');
        } else {
            const messageCtx = messageCanvas.getContext('2d');
            const scratchCtx = scratchCanvas.getContext('2d');
            const scratchSound = document.getElementById('scratchSound');

            // Set canvas dimensions
            messageCanvas.width = ${this.getCanvasWidth(cardData)};
            messageCanvas.height = ${this.getCanvasHeight(cardData)};
            scratchCanvas.width = ${this.getCanvasWidth(cardData)};
            scratchCanvas.height = ${this.getCanvasHeight(cardData)};

            // Preload sound
            const sound = new Audio('${this.getAudioUrl(cardData)}');
            sound.loop = false;
            sound.volume = 1.0;

            // Draw the message on the message canvas (bottom layer) - EXACT SAME
            function drawMessage() {
                messageCtx.clearRect(0, 0, messageCanvas.width, messageCanvas.height);
                messageCtx.font = '30px Comic Sans MS';
                messageCtx.fillStyle = '#fff';
                messageCtx.textAlign = 'center';
                messageCtx.textBaseline = 'middle';
                const message = "${hiddenMessage}";
                messageCtx.fillText(message, messageCanvas.width / 2, messageCanvas.height / 2);
            }

            // Draw the scratch layer on the scratch canvas (top layer) - EXACT SAME
            function drawScratchLayer() {
                ${scratchTextureUrl ? `
                const scratchLayer = new Image();
                scratchLayer.src = '${scratchTextureUrl}';
                scratchLayer.onload = () => {
                    scratchCtx.drawImage(scratchLayer, 0, 0, scratchCanvas.width, scratchCanvas.height);
                    scratchCtx.strokeStyle = '#000';
                    scratchCtx.lineWidth = 2;
                    scratchCtx.setLineDash([5, 5]);
                    scratchCtx.strokeRect(0, 0, scratchCanvas.width, scratchCanvas.height);
                    scratchCtx.setLineDash([]);
                    scratchCtx.font = '40px Comic Sans MS';
                    scratchCtx.fillStyle = '#000';
                    scratchCtx.textAlign = 'center';
                    scratchCtx.textBaseline = 'middle';
                    scratchCtx.fillText('Scratch Me', scratchCanvas.width / 2, scratchCanvas.height / 2);
                };
                scratchLayer.onerror = () => {
                    console.log('Failed to load scratch texture. Using fallback.');
                    drawFallbackScratchLayer();
                };
                ` : `
                drawFallbackScratchLayer();
                `}
            }

            function drawFallbackScratchLayer() {
                scratchCtx.fillStyle = '#c0c0c0';
                scratchCtx.fillRect(0, 0, scratchCanvas.width, scratchCanvas.height);
                scratchCtx.strokeStyle = '#000';
                scratchCtx.lineWidth = 2;
                scratchCtx.setLineDash([5, 5]);
                scratchCtx.strokeRect(0, 0, scratchCanvas.width, scratchCanvas.height);
                scratchCtx.setLineDash([]);
                scratchCtx.font = '40px Comic Sans MS';
                scratchCtx.fillStyle = '#000';
                scratchCtx.textAlign = 'center';
                scratchCtx.textBaseline = 'middle';
                scratchCtx.fillText('Scratch Me', scratchCanvas.width / 2, scratchCanvas.height / 2);
            }

            // Initialize both layers - EXACT SAME
            drawMessage();
            drawScratchLayer();

            // Scratching logic on the scratch canvas - EXACT SAME
            let isScratching = false;
            let scratchedPixels = 0;
            const brushRadius = 12;
            const totalPixels = scratchCanvas.width * scratchCanvas.height;
            const intervalThreshold = totalPixels * 0.05;
            let lastBurstAt = 0;
            let isSoundPlaying = false;

            // Function to play the sound - EXACT SAME
            function playSound() {
                if (!isSoundPlaying) {
                    isSoundPlaying = true;
                    sound.volume = 1.0;
                    sound.play().catch(err => console.log('Sound play error:', err));
                }
            }

            // Add an event listener to detect when the sound ends naturally - EXACT SAME
            sound.addEventListener('ended', () => {
                isSoundPlaying = false;
                console.log('Sound finished playing naturally.');
                if (isScratching) {
                    playSound();
                }
            });

            // Stop sound if the mouse leaves the canvas - EXACT SAME
            function stopSoundOnLeave() {
                if (isScratching) {
                    isScratching = false;
                }
            }

            // Event listeners - EXACT SAME AS JOE'S SCRIPT
            scratchCanvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isScratching = true;
                playSound();
            });
            scratchCanvas.addEventListener('mouseup', (e) => {
                e.preventDefault();
                isScratching = false;
            });
            scratchCanvas.addEventListener('mouseleave', stopSoundOnLeave);
            scratchCanvas.addEventListener('mousemove', scratch);
            scratchCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isScratching = true;
                playSound();
            });
            scratchCanvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                isScratching = false;
            });
            scratchCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                scratch(e.touches[0]);
            });

            // Scratch function - EXACT SAME PIXEL-BY-PIXEL LOGIC
            function scratch(event) {
                if (!isScratching) return;
                const rect = scratchCanvas.getBoundingClientRect();
                const scaleX = scratchCanvas.width / rect.width;
                const scaleY = scratchCanvas.height / rect.height;
                const x = (event.clientX - rect.left) * scaleX;
                const y = (event.clientY - rect.top) * scaleY;
                scratchCtx.globalCompositeOperation = 'destination-out';
                scratchCtx.beginPath();
                scratchCtx.arc(x, y, brushRadius, 0, Math.PI * 2);
                scratchCtx.fillStyle = 'rgba(0, 0, 0, 1)';
                scratchCtx.fill();

                const scratchedArea = Math.PI * brushRadius * brushRadius;
                scratchedPixels += scratchedArea;
                console.log('Scratched pixels:', scratchedPixels, 'Interval threshold:', intervalThreshold);
                checkReveal();
            }

            // Fireworks logic - EXACT SAME AS JOE'S SCRIPT
            function checkReveal() {
                const intervalsPassed = Math.floor(scratchedPixels / intervalThreshold);
                if (intervalsPassed > lastBurstAt) {
                    lastBurstAt = intervalsPassed;
                    console.log('Firing ${animation}-themed fireworks at interval:', intervalsPassed);
                    if (typeof confetti === 'function') {
                        // Calculate the bottom of the scratch canvas in viewport coordinates
                        const rect = scratchCanvas.getBoundingClientRect();
                        const canvasBottomY = (rect.bottom / window.innerHeight);
                        const canvasCenterX = (rect.left + rect.width / 2) / window.innerWidth;

                        // Animation-based fireworks
                        ${this.generateFireworksCode(animation)}
                    } else {
                        console.log('Confetti library not loaded.');
                    }
                }
            }

            // Check if confetti library loaded - EXACT SAME
            window.addEventListener('load', () => {
                if (typeof confetti === 'undefined') {
                    console.log('Confetti library failed to load.');
                } else {
                    console.log('Confetti library loaded successfully.');
                }
            });

            console.log('‚úÖ DUAL CANVAS SCRATCH CARD INITIALIZED - PROFESSIONAL MODE');
            console.log('üéØ Message Canvas (Bottom Layer):', messageCanvas.width + 'x' + messageCanvas.height);
            console.log('üé® Scratch Canvas (Top Layer):', scratchCanvas.width + 'x' + scratchCanvas.height);
            console.log('üî• Animation Type:', '${animation}');
            console.log('üí® Smoke Effect:', ${smokeEffect});
        }

        // ADDITIONAL EFFECTS - Smoke system if enabled
        ${smokeEffect ? this.generateSmokeSystem(glowColor) : '// Smoke effect disabled'}

        console.log('üéØ PROFESSIONAL DUAL CANVAS CARD LOADED SUCCESSFULLY!');
        `;
    }

    /**
     * Get canvas width from card data
     */
    getCanvasWidth(cardData) {
        const scratchElement = cardData.elements?.find(e => e.type === 'scratch' || e.type === 'scratch-area');
        if (scratchElement && scratchElement.position?.width) {
            return this.parsePixels(scratchElement.position.width) || 350;
        }
        return 350;
    }

    /**
     * Get canvas height from card data
     */
    getCanvasHeight(cardData) {
        const scratchElement = cardData.elements?.find(e => e.type === 'scratch' || e.type === 'scratch-area');
        if (scratchElement && scratchElement.position?.height) {
            return this.parsePixels(scratchElement.position.height) || 150;
        }
        return 150;
    }

    /**
     * Get audio URL for scratch sound
     */
    getAudioUrl(cardData) {
        const { soundEffect, soundEffectBase64 } = cardData;
        
        if (soundEffectBase64) {
            return soundEffectBase64;
        } else if (soundEffect && soundEffect !== '#beep') {
            if (this.isWebAppAsset(soundEffect)) {
                return `${this.baseUrl}/assets/audio/${soundEffect}`;
            } else {
                return soundEffect;
            }
        }
        
        return ''; // Will fallback to Web Audio API beep
    }

    /**
     * Generate fireworks code based on animation type
     */
    generateFireworksCode(animation) {
        switch (animation) {
            case 'hearts':
                return `
                // First burst: Pink sparkles
                confetti({
                    particleCount: 30,
                    spread: 40,
                    origin: { x: canvasCenterX, y: canvasBottomY },
                    colors: ['#FF69B4', '#FF1493'],
                    scalar: 1.2,
                    gravity: 0.8,
                    ticks: 100,
                    angle: 90,
                    startVelocity: 20
                });
                // Second burst: Lighter pink accents
                setTimeout(() => {
                    confetti({
                        particleCount: 20,
                        spread: 60,
                        origin: { x: canvasCenterX, y: canvasBottomY },
                        colors: ['#C71585', '#FF69B4'],
                        scalar: 0.8,
                        gravity: 1.0,
                        ticks: 80,
                        angle: 90,
                        startVelocity: 25
                    });
                }, 100);`;
            
            case 'sparkles':
                return `
                // Gold sparkle burst
                confetti({
                    particleCount: 25,
                    spread: 50,
                    origin: { x: canvasCenterX, y: canvasBottomY },
                    colors: ['#FFD700', '#FFA500', '#FFFF00'],
                    scalar: 1.0,
                    gravity: 0.6,
                    ticks: 120,
                    angle: 90,
                    startVelocity: 22
                });
                setTimeout(() => {
                    confetti({
                        particleCount: 15,
                        spread: 70,
                        origin: { x: canvasCenterX, y: canvasBottomY },
                        colors: ['#FFE55C', '#FFD700'],
                        scalar: 0.6,
                        gravity: 0.8,
                        ticks: 100,
                        angle: 90,
                        startVelocity: 18
                    });
                }, 150);`;
            
            default:
                return `
                // Default colorful burst
                confetti({
                    particleCount: 30,
                    spread: 45,
                    origin: { x: canvasCenterX, y: canvasBottomY },
                    colors: ['#667eea', '#764ba2', '#f093fb', '#f5576c'],
                    scalar: 1.1,
                    gravity: 0.7,
                    ticks: 110,
                    angle: 90,
                    startVelocity: 21
                });`;
        }
    }

    /**
     * Generate smoke system for enhanced effects
     */
    generateSmokeSystem(glowColor) {
        return `
        // CANVAS-BASED SMOKE EFFECT SYSTEM
        class SmokeParticle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = -(Math.random() * 2 + 1);
                this.life = 1.0;
                this.maxLife = Math.random() * 300 + 200;
                this.age = 0;
                this.size = Math.random() * 20 + 10;
                this.maxSize = this.size * (2 + Math.random() * 2);
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02;
                this.baseColor = this.parseColor(color);
            }
            
            parseColor(color) {
                const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(color);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 102, g: 126, b: 234 };
            }
            
            update() {
                this.age++;
                this.vx += (Math.random() - 0.5) * 0.01;
                this.vy -= 0.05;
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.995;
                this.vy *= 0.995;
                
                if (this.size < this.maxSize) {
                    this.size += 0.4;
                }
                
                this.rotation += this.rotationSpeed;
                this.life = Math.max(0, 1 - (this.age / this.maxLife));
                
                return this.life > 0;
            }
            
            draw(ctx) {
                ctx.save();
                let alpha = this.life * 0.6;
                if (this.y < 50) alpha *= (this.y / 50);
                
                let ageRatio = 1 - this.life;
                let red = Math.floor(this.baseColor.r * (1 - ageRatio * 0.2));
                let green = Math.floor(this.baseColor.g + ageRatio * 15);
                let blue = Math.floor(this.baseColor.b + ageRatio * 25);
                
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                let gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                gradient.addColorStop(0, \`rgba(\${red}, \${green}, \${blue}, \${alpha})\`);
                gradient.addColorStop(0.3, \`rgba(\${red}, \${green}, \${blue}, \${alpha * 0.7})\`);
                gradient.addColorStop(0.7, \`rgba(\${red}, \${green}, \${blue}, \${alpha * 0.3})\`);
                gradient.addColorStop(1, \`rgba(\${red}, \${green}, \${blue}, 0)\`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class SmokeSystem {
            constructor() {
                this.particles = [];
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();
                this.isRunning = false;
            }
            
            setupCanvas() {
                this.canvas.style.cssText = \`
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 3;
                \`;
                
                const container = document.querySelector('.card-container');
                if (container) {
                    const rect = container.getBoundingClientRect();
                    this.canvas.width = rect.width;
                    this.canvas.height = rect.height;
                    container.style.position = 'relative';
                    container.appendChild(this.canvas);
                }
            }
            
            start() {
                this.isRunning = true;
                this.animate();
            }
            
            animate() {
                if (!this.isRunning) return;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Create new particles
                if (Math.random() < 0.3) {
                    const x = Math.random() * this.canvas.width;
                    const y = this.canvas.height + 50;
                    this.particles.push(new SmokeParticle(x, y, '${glowColor}'));
                }
                
                // Update and filter particles
                this.particles = this.particles.filter(particle => particle.update());
                
                // Draw particles
                this.particles.forEach(particle => particle.draw(this.ctx));
                
                // Limit particles for performance
                if (this.particles.length > 100) {
                    this.particles = this.particles.slice(0, 80);
                }
                
                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize smoke system
        const smokeSystem = new SmokeSystem();
        smokeSystem.start();
        console.log('üí® Smoke effect system initialized');`;
    }

    /**
     * Helper function to convert hex to rgba
     */
    hexToRgba(hex, alpha) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (result) {
            const r = parseInt(result[1], 16);
            const g = parseInt(result[2], 16);
            const b = parseInt(result[3], 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        return `rgba(102, 126, 234, ${alpha})`;
    }
}

// Export the professional dual canvas generator
module.exports = new AdvancedCardGenerator();
